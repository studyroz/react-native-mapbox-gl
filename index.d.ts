declare module 'mapbox__react-native-mapbox-gl';

import {
    Component
} from 'react';

import {
    ViewProperties,
    ViewStyle,
} from 'react-native';

/**
 * These are the typings for the Mapbox React Native module.
 * They are modelled after the documentation and may not be 100% accurate.
 *
 * Generated by Ryan Pope (https://github.com/RyPope)
 */

type Anchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
type Visibility = 'visible' | 'none'
type Alignment = 'map' | 'viewport';
type AutoAlignment = Alignment | 'auto';

type NamedStyles<T> = {
    [P in keyof T]: SymbolLayerStyle | RasterLayerStyle | LineLayerStyle | FillLayerStyle |
        FillExtrusionLayerStyle | CircleLayerStyle | BackgroundLayerStyle
};

declare namespace MapboxGL {
    function removeCustomHeader(headerName: string): void;
    function addCustomHeader(headerName: string, headerValue: string): void;
    function setAccessToken(accessToken: string): void;
    function getAccessToken(): Promise<void>;
    function setTelemetryEnabled(telemetryEnabled: boolean): void;
    function setApiBaseUrl(url: string | undefined): void

    /**
     * Components
     */
    class MapView extends Component<MapViewProps> {
        getPointInView(coordinate: Array<number>): Promise<void>;
        getCoordinateFromView(point: Array<number>): Promise<void>;
        getVisibleBounds(): Promise<number[][]>;
        queryRenderedFeaturesAtPoint(coordinate: Array<number>, filter?: any[], layerIds?: Array<string>): Promise<GeoJSON.FeatureCollection>;
        queryRenderedFeaturesInRect(coordinate: Array<number>, filter?: any[], layerIds?: Array<string>): Promise<GeoJSON.FeatureCollection>;
        fitBounds(northEastCoordinates: Array<number>, southWestCoordinates: Array<number>, padding?: number, duration?: number): void;
        flyTo(coordinates: Array<number>, duration?: number): void;
        moveTo(coordinates: Array<number>, duration?: number): void;
        zoomTo(zoomLevel: number, duration?: number): void;
        setCamera(config: any): void;
        takeSnap(writeToDisk: boolean): Promise<string>;
        getZoom(): Promise<number>;
        getCenter(): Promise<Array<number>>;
        setGeoJSON: (id: string, json: string) => void
    }

    class Camera extends Component<CameraProps> {
        fitBounds: (
            northEastCoordinates: Coordinate,
            southWestCoordinates: Coordinate,
            padding?: number | number[],
            duration?: number
          ) => void
        flyTo: (coordinate: Coordinate, duration?: number) => Promise<void>
        moveTo: (coordinate: Coordinate, duration?: number) => Promise<void>
        zoomTo: (zoomLevel: number, duration?: number) => Promise<void>
        setCamera: (config: CameraConfig) => Promise<void>
    }

    class Images extends Component<ImagesProps> {

    }

    class Light extends Component<LightProps> { }

    class PointAnnotation extends Component<PointAnnotationProps> { }
    class Callout extends Component<CalloutProps> { }

    /**
     * Sources
     */
    class VectorSource extends Component<VectorSourceProps> { }
    class ShapeSource extends Component<ShapeSourceProps> { }
    class RasterSource extends Component<RasterSourceProps> { }

    /**
     * Layers
     */
    class BackgroundLayer extends Component<BackgroundLayerProps> { }
    class CircleLayer extends Component<CircleLayerProps> { }
    class FillExtrusionLayer extends Component<FillExtrusionLayerProps> { }
    class FillLayer extends Component<FillLayerProps> { }
    class LineLayer extends Component<LineLayerProps> { }
    class RasterLayer extends Component<RasterLayerProps> { }
    class SymbolLayer extends Component<SymbolLayerProps> { }


    /**
     * Offline
     */
    class offlineManager extends Component {
        createPack(options: OfflineCreatePackOptions, progressListener?: () => void, errorListener?: () => void): void;
        deletePack(name: string): Promise<void>;
        getPacks(): Promise<void>;
        getPack(name: string): Promise<void>;
        setTileCountLimit(limit: number): void;
        setProgressEventThrottle(throttleValue: number): void;
        subscribe(packName: string, progressListener: () => void, errorListener: () => void): void;
        unsubscribe(packName: string): void;
    }

    class snapshotManager extends Component {
        takeSnap(options: SnapshotOptions): Promise<void>;
    }

    /**
     * Constants
     */
    enum UserTrackingModes {
        None = 0,
        Follow = 1,
        FollowWithCourse = 2,
        FollowWithHeading = 3,
    }

    enum InterpolationMode {
        Exponential = 0,
        Categorical = 1,
        Interval = 2,
        Identity = 3,
    }

    enum StyleURL {
        Street = 'mapbox://styles/mapbox/streets-v11',
        Dark = 'mapbox://styles/mapbox/dark-v10',
        Light = 'mapbox://styles/mapbox/light-v10',
        Outdoors = 'mapbox://styles/mapbox/outdoors-v11',
        Satellite = 'mapbox://styles/mapbox/satellite-v9',
        SatelliteStreeet = 'mapbox://styles/mapbox/satellite-streets-v11',
        TrafficDay = 'mapbox://styles/mapbox/navigation-preview-day-v4',
        TrafficNight = 'mapbox://styles/mapbox/navigation-preview-night-v4'
    }

    enum StyleSource {
        DefaultSourceID = 0
    }
}

interface MapViewProps extends ViewProperties {
    animated?: boolean;
    centerCoordinate?: Array<number>;
    showUserLocation?: boolean;
    userTrackingMode?: number;
    userLocationVerticalAlignment?: number;
    contentInset?: Array<number>;
    heading?: number;
    pitch?: number;
    style?: any;
    styleURL?: string;
    zoomLevel?: number;
    minZoomLevel?: number;
    maxZoomLevel?: number;
    localizeLabels?: boolean;
    zoomEnabled?: boolean;
    scrollEnabled?: boolean;
    pitchEnabled?: boolean;
    rotateEnabled?: boolean;
    attributionEnabled?: boolean;
    logoEnabled?: boolean;
    compassEnabled?: boolean;
    surfaceView?: boolean;
    regionWillChangeDebounceTime?: number;
    regionDidChangeDebounceTime?: number;

    draggableLayerID?: string

    onPress?: (payload: OnPressPayloadInternal) => void;
    onLongPress?: (payload: OnPressPayloadInternal) => void;
    onDrag?: (payload: OnDragPayloadInternal) => void
    onDragEnd?: (payload: OnDragPayloadInternal) => void
    onRegionWillChange?: (payload: RegionChangePayloadInternal) => void;
    onRegionIsChanging?: (payload: RegionChangePayloadInternal) => void;
    onRegionDidChange?: (payload: RegionChangePayloadInternal) => void;
    onUserLocationUpdate?: () => void;
    onWillStartLoadingMap?: () => void;
    onDidFinishLoadingMap?: () => void;
    onDidFailLoadingMap?: () => void;
    onWillStartRenderingFrame?: () => void;
    onDidFinishRenderingFrame?: () => void;
    onDidFinishRenderingFrameFully?: () => void;
    onWillStartRenderingMap?: () => void;
    onDidFinishRenderingMap?: () => void;
    onDidFinishRenderingMapFully?: () => void;
    onDidFinishLoadingStyle?: () => void;
    onUserTrackingModeChange?: () => void;
}

interface Bounds {
    ne: number[]
    sw: number[]
    paddingLeft?: number
    paddingRight?: number
    paddingTop?: number
    paddingBottom?: number
}
interface CameraSettings {
    centerCoordinate?: number[]
    heading?: number
    pitch?: number
    bounds?: Bounds
    zoomLevel?: number
}
export interface CameraProps {
    animationDuration?: number
    animationMode?: 'easeTo' | 'flyTo' | 'moveTo'
    defaultSettings?: CameraSettings
    centerCoordinate?: number[]
    heading?: number
    pitch?: number
    bounds?: Bounds
    zoomLevel?: number
    minZoomLevel?: number
    maxZoomLevel?: number
    followUserLocation?: boolean
    followUserMode?: 'normal' | 'compass' | 'course'
    followZoomLevel?: number
    followPitch?: number
    followHeading?: number
    triggerKey?: any
    alignment?: any[]
    isUserInteraction?: boolean
}
export interface ImagesProps {
    images?: ImageAssetsProps
}

export interface ImageAssetsProps {
    assets: string[]
}

interface CameraConfig {
    centerCoordinate?: Coordinate
    zoomLevel?: number
    animationDuration?: number
    stops?: any[]
}

type Coordinate = number[] // 数量为2，第一个是long，第二个是lat

interface Geometry {
    type: string
    coordinates: Coordinate
}

interface LocationChangeProperties {
    animated: boolean
    heading: number
    pitch: number
    isUserInteraction: boolean
    zoomLevel: number
    visibleBounds: number[][]
}

interface PressProperties {
    screenPointX: number
    screenPointY: number
}
export interface RegionChangePayloadInternal {
    type: string
    geometry: Geometry
    properties: LocationChangeProperties
}

export interface OnPressPayloadInternal {
    type: string
    geometry: Geometry
    properties: PressProperties
}

export interface OnDragPayloadInternal {
    coordinate: [number, number]
    id: string
}

export interface LightStyle {
    anchor?: Alignment;
    position?: Array<number>;
    color?: string;
    intensity?: number;
}

export interface BackgroundLayerStyle {
    visibility?: Visibility;
    backgroundColor?: string | ExpressionZoom;
    backgroundPattern?: string | ExpressionZoom;
    backgroundOpacity?: number | ExpressionZoom;
}

export interface CircleLayerStyle {
    visibility?: Visibility;
    circleRadius?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleBlur?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleTranslate?: Array<number> | ExpressionZoom;
    circleTranslateAnchor?: Alignment | ExpressionZoom;
    circlePitchScale?: Alignment | ExpressionZoom;
    circlePitchAlignment?: Alignment | ExpressionZoom;
    circleStrokeWidth?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleStrokeColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    circleStrokeOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
}

export interface FillExtrusionLayerStyle {
    visibility?: Visibility;
    fillExtrusionOpacity?: number | ExpressionZoom;
    fillExtrusionColor?: string | ExpressionZoom;
    fillExtrusionTranslate?: Array<number> | ExpressionZoom;
    fillExtrusionTranslateAnchor?: Alignment | ExpressionZoom;
    fillExtrusionPattern?: string | ExpressionZoom | ExpressionFeature;
    fillExtrusionHeight?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    fillExtrusionBase?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
}

export interface FillLayerStyle {
    visibility?: Visibility;
    fillAntialias?: boolean | ExpressionZoom;
    fillOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    fillColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    fillOutlineColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    fillTranslate?: Array<number> | ExpressionZoom;
    fillTranslateAnchor?: Alignment | ExpressionZoom;
    fillPattern?: string | ExpressionZoom | ExpressionFeature;
}

export interface LineLayerStyle {
    lineCap?: 'butt' | 'round' | 'square' | ExpressionZoom;
    lineJoin?: 'bevel' | 'round' | 'miter' | ExpressionZoom;
    lineMiterLimit?: number | ExpressionZoom;
    lineRoundLimit?: number | ExpressionZoom;
    visibility?: Visibility;
    lineOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineTranslate?: Array<number> | ExpressionZoom;
    lineTranslateAnchor?: Alignment | ExpressionZoom;
    lineWidth?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineGapWidth?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineOffset?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineBlur?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    lineDasharray?: Array<number> | ExpressionZoom;
    linePattern?: string | ExpressionZoom | ExpressionFeature;
}

export interface RasterLayerStyle {
    visibility?: Visibility;
    rasterOpacity?: number | ExpressionZoom;
    rasterHueRotate?: number | ExpressionZoom;
    rasterBrightnessMin?: number | ExpressionZoom;
    rasterBrightnessMax?: number | ExpressionZoom;
    rasterSaturation?: number | ExpressionZoom;
    rasterContrast?: number | ExpressionZoom;
    rasterResampling?: 'linear' | 'nearest' | ExpressionZoom;
    rasterFadeDuration?: number | ExpressionZoom;
}

export interface SymbolLayerStyle {
    symbolPlacement?: 'point' | 'line' | ExpressionZoom;
    symbolSpacing?: number | ExpressionZoom;
    symbolAvoidEdges?: boolean | ExpressionZoom;
    symbolZOrder?: ZOrder | ExpressionZoom;
    iconAllowOverlap?: boolean | ExpressionZoom;
    iconIgnorePlacement?: boolean | ExpressionZoom;
    iconOptional?: boolean | ExpressionZoom;
    iconRotationAlignment?: AutoAlignment | ExpressionZoom;
    iconSize?: number | ExpressionZoom | ExpressionFeature;
    iconTextFit?: 'none' | 'width' | 'height' | 'both' | ExpressionZoom;
    iconTextFitPadding?: Array<number> | ExpressionZoom;
    iconImage?: string | ExpressionZoom | ExpressionFeature;
    iconRotate?: number | ExpressionZoom | ExpressionFeature;
    iconPadding?: number | ExpressionZoom;
    iconKeepUpright?: boolean | ExpressionZoom;
    iconOffset?: Array<number>  | ExpressionZoom | ExpressionFeature;
    iconAnchor?: Anchor | ExpressionZoom | ExpressionFeature;
    iconPitchAlignment?: AutoAlignment | ExpressionZoom;
    textPitchAlignment?: AutoAlignment | ExpressionZoom;
    textRotationAlignment?: AutoAlignment | ExpressionZoom;
    textField?: string | ExpressionZoom;
    textFont?: Array<string> | ExpressionZoom | ExpressionFeature;
    textSize?: number | ExpressionZoom | ExpressionFeature;
    textMaxWidth?: number | ExpressionZoom | ExpressionFeature;
    textLineHeight?: number | ExpressionZoom;
    textLetterSpacing?: number | ExpressionZoom | ExpressionFeature;
    textJustify?: 'left' | 'center' | 'right' | 'auto' | ExpressionZoom | ExpressionFeature;
    textAnchor?: Anchor | ExpressionZoom | ExpressionFeature;
    textMaxAngle?: number | ExpressionZoom;
    textRotate?: number | ExpressionZoom | ExpressionFeature;
    textPadding?: number | ExpressionZoom;
    textKeepUpright?: boolean | ExpressionZoom;
    textTransform?: 'none' | 'uppercase' | 'lowercase' | ExpressionZoom | ExpressionFeature;
    textOffset?: Array<number> | ExpressionZoom | ExpressionFeature;
    textAllowOverlap?: boolean | ExpressionZoom;
    textIgnorePlacement?: boolean | ExpressionZoom;
    textOptional?: boolean | ExpressionZoom;
    visibility?: Visibility;
    iconOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    iconColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    iconHaloColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    iconHaloWidth?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    iconHaloBlur?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    iconTranslate?: Array<number> | ExpressionZoom;
    iconTranslateAnchor?: Alignment | ExpressionZoom;
    textOpacity?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    textColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    textHaloColor?: string | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    textHaloWidth?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    textHaloBlur?: number | ExpressionZoom | ExpressionFeature | ExpressionFeatureState;
    textTranslate?: Array<number> | ExpressionZoom;
    textTranslateAnchor?: Alignment | ExpressionZoom;
}

interface Point {
    x: number;
    y: number;
}

interface LightProps {
    style: LightStyle;
}

interface PointAnnotationProps {
    id: string;
    title?: string;
    snippet?: string;
    selected?: boolean;
    coordinate: Array<number>;
    anchor?: Point;
    onSelected?: () => void;
    onDeselected?: () => void;
}

interface CalloutProps {
    id?: string;
    url?: string;
    onPress?: () => void;
    hitbox?: any;
}

interface VectorSourceProps {
    title?: string;
    style?: ViewStyle;
    containerStyle?: ViewStyle;
    contentStyle?: ViewStyle;
    tipStyle?: ViewStyle;
    textStyle?: ViewStyle;
}

interface ShapeSourceProps {
    id?: string;
    url?: string;
    shape?: any;
    cluter?: boolean;
    clusterRadius?: number;
    clusterMaxZoomLevel?: number;
    maxZoomLevel?: number;
    buffer?: number;
    tolerance?: number;
    images?: any;
    onPress?: (e: any) => void;
    hitbox?: any;
}

interface RasterSourceProps {
    id?: MapboxGL.StyleSource;
    url?: string;
    minZoomLevel?: number;
    maxZoomLevel?: number;
    tileSize?: number;
    tms?: boolean;
    attribution?: string;
}

interface LayerBaseProps {
    id?: string;
    sourceID?: MapboxGL.StyleSource;
    sourceLayerID?: string;
    aboveLayerID?: string;
    belowLayerID?: string;
    layerIndex?: number;
    filter?: any[];
    minZoomLevel?: number;
    maxZoomLevel?: number;
}

export interface BackgroundLayerProps extends LayerBaseProps {
    style?: BackgroundLayerStyle;
}

export interface CircleLayerProps extends LayerBaseProps {
    style?: CircleLayerStyle;
}

export interface FillExtrusionLayerProps extends LayerBaseProps {
    style?: FillExtrusionLayerStyle;
}

export interface FillLayerProps extends LayerBaseProps {
    style?: FillLayerStyle;
}

export interface LineLayerProps extends LayerBaseProps {
    style?: LineLayerStyle;
}

export interface RasterLayerProps extends LayerBaseProps {
    style?: RasterLayerStyle;
}

export interface SymbolLayerProps extends LayerBaseProps {
    style?: SymbolLayerStyle;
}

export interface OfflineCreatePackOptions {
    name?: string;
    styleURL?: MapboxGL.StyleURL;
    bounds?: Array<number>;
    minZoom?: number;
    maxZoom?: number;
    metadata?: any;
}

export interface SnapshotOptions {
    centerCoordinate?: Array<number>;
    width?: number;
    height?: number;
    zoomLevel?: number;
    pitch?: number;
    heading?: number;
    styleURL?: MapboxGL.StyleURL;
    writeToDisk?: boolean;
}

export default MapboxGL;
